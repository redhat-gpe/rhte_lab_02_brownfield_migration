:noaudio:
:scrollbar:
:data-uri:
:toc2:
:linkattrs:

== Microservices Security Lab

In this lab, you secure decomposed coolstore microservices from last module with token-based authentication and authorization, using Red Hat Single Sign-On (Red Hat SSO) as the authentication server.

.Goal
* Enhance the code and configuration of the applications to provide token-based authentication and authorization

.Prerequisites
* Completion of all of the previous labs
* Successful deployment of the catalog, inventory, and cart services
* Access to `jq` command-line json parser.

:numbered:

== Configure, Deploy, and Test Red Hat SSO on OpenShift

Red Hat provides a supported Docker image for Red Hat Single Sign-On version 7.2. The `~/labs/modern-coolstore/etc/rhsso` folder of the lab source code includes a template for Red Hat Single Sign-On 7.2 using PostgreSQL as the database.

=== Configure Red Hat SSO on OpenShift

. Export the name of the `coolstore-rhsso` OpenShift project as an environment variable:
+
[source,text]
----
$ export INFRA_PRJ=<name of your OpenShift coolstore infra project>
----

. Create a secret for the Red Hat SSO deployment using the `rhsso-app-secret.json` template in the `etc/rhsso` folder:
+
[source,text]
----
$ cd ~/labs/modern-coolstore
$ oc create -f etc/rhsso/rhsso-app-secret.json -n $INFRA_PRJ
----
+
.Sample Output
[source,text]
----
serviceaccount "sso-service-account" created
secret "sso-app-secret" created
----
* The template defines a secret that contains the keystore for Red Hat SSO (to provide access over SSL, using the key alias of `jboss` and `mykeystorepassword` as the password) and JGroups (required for clustering, but not used in the lab). The template also defines a `sso-service-account` service account that has access to the secret.
. Give cluster view rights to the `sso-service-account` service account:
+
[source,text]
----
$ oc policy add-role-to-user view system:serviceaccount:$INFRA_PRJ:sso-service-account -n $INFRA_PRJ
----

=== Deploy Red Hat SSO on OpenShift

. Create a deployment from the `sso72-postgresql-persistent.json` template:
+
[source,text]
----
$ oc process -f etc/rhsso/sso72-postgresql-persistent.json -p HTTPS_NAME=jboss -pHTTPS_PASSWORD=mykeystorepass -pSSO_ADMIN_USERNAME=admin -pSSO_ADMIN_PASSWORD=admin -p SSO_REALM=coolstore | oc create -f -
----
+
.Sample Output
[source,text]
----
service "sso" created
service "secure-sso" created
service "sso-postgresql" created
route "sso" created
route "secure-sso" created
deploymentconfig "sso" created
deploymentconfig "sso-postgresql" created
persistentvolumeclaim "sso-postgresql-claim" created
----
* The `sso72-postgresql-persistent.json` template in the `etc/rhsso` folder defines the OpenShift objects for the deployment of the Red Hat SSO server (`BuildConfig`, `DeploymentConfig`, `Service`, and `Route`) and PostgreSQL (`BuildConfig`, `DeploymentConfig`, `Service`, `Persistent Volume Claim`).
* This creates a Red Hat SSO instance, using the `admin:admin` password and `coolstore` realm.
* Note that two services and routes are created for the Red Hat SSO--an unsecured one that exposes the Red Hat SSO endpoints over HTTP, and a secure one that uses HTTPS.
. Follow the deployment on the OpenShift web console.
* When fully deployed, expect the `$INFRA_PRJ` project to look like this:
+
image::images/rhsso-deployed.png[]
. In a browser, navigate to the URL of the Red Hat SSO server.
* If you chose the SSL-enabled URL, ignore the safety warning and proceed to the URL.
. Click the *Administration Console* link and log in with `admin/admin` credentials.
* Expect to see the *Realm Settings* screen of the `Coolstore` realm:
+
image::images/rhsso-coolstore-realm.png[]

. From the left side of the page, open the *Clients* tab and click *Create* to create a client.
* You create a client in the realm so that you are able to test the secured microservices--you want to be able to obtain a token based on user credentials directly from the Red Hat SSO server using a Direct Access Grant.
. Enter `curl` as the *Client ID* and click *Save*:
+
image::images/rhsso-curl-client.png[]
. In the *Settings* tab, disable *Standard Flow* and enable *Direct Access Grants*, then click *Save*:
+
image::images/rhsso-curl-client-grant.png[]
. Define the realm roles:
.. From the left side of the page, open the *Roles* tab and click *Add Role* to create a realm role.
.. Enter `coolstore` as the *Role Name* and and click *Save*:
+
image::images/rhsso-coolstore-realm-role.png[]
. Create a user:
.. From the left side of the page, select the *Users* tab and click *Add User*.
.. Enter `user1` as the username and click *Save*.
. Click the *Credentials* tab to set the password for the user, enter `user` as the password, set *Temporary* to off, and click *Reset Password*:
+
image::images/rhsso-user-credentials.png[]
. Select the *Role Mappings* tab to map the `coolstore` role to `user1` and select the `coolstore` role in the *Available Roles* list, then click *Add selected*:
+
image::images/rhsso-user-roles.png[]

=== Test Red Hat SSO Configuration on OpenShift

In this section, you obtain a token for the user using `curl` and you test the Red Hat SSO configuration using the token.

. Open a terminal shell and export the HTTPS URL of the Red Hat SSO server as a environment variable:
+
[source,text]
----
$ export RHSSO_URL=<https url of the RHSSO server>
----
. Use `curl` to obtain a token from the Red Hat SSO server:
+
[source,text]
----
$ curl -X POST "$RHSSO_URL/auth/realms/coolstore/protocol/openid-connect/token" \
 -H "Content-Type: application/x-www-form-urlencoded" \
 -d "username=user1" \
 -d "password=user" \
 -d "grant_type=password" \
 -d "client_id=curl" \
 --insecure | jq
----
+
.Sample Output
[source,json]
----
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJaTVhMTjNtOHl5Z0p5UnZHQTlQaHBlT0pWMFg2dHhfMlZDZndFd1dBVjRnIn0.eyJqdGkiOiIxZjk4MWI3NS1lNmM5LTQ5MmItOTQ1Zi05YWFmYmU3OGVjNWUiLCJleHAiOjE1MzMxMDQ3NTAsIm5iZiI6MCwiaWF0IjoxNTMzMTA0NDUwLCJpc3MiOiJodHRwczovL3NlY3VyZS1zc28tYXBwbGUuMTI3LjAuMC4xLm5pcC5pby9hdXRoL3JlYWxtcy9jb29sc3RvcmUiLCJhdWQiOiJjdXJsIiwic3ViIjoiNmY2MzBmMTMtNTczNy00NmNiLWI5MjUtYmNkNmE0MzMwODNjIiwidHlwIjoiQmVhcmVyIiwiYXpwIjoiY3VybCIsImF1dGhfdGltZSI6MCwic2Vzc2lvbl9zdGF0ZSI6IjliMDlhZjI3LWU4MWYtNGQ5MS04Y2QxLTg5ZjBjYzdhMGJjMSIsImFjciI6IjEiLCJhbGxvd2VkLW9yaWdpbnMiOltdLCJyZWFsbV9hY2Nlc3MiOnsicm9sZXMiOlsidW1hX2F1dGhvcml6YXRpb24iLCJjb29sc3RvcmUiXX0sInJlc291cmNlX2FjY2VzcyI6eyJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJ1c2VyMSJ9.V0FLUzZrd8jqfDM1CpuX_40CBQrnxmVRkgy51hXT5sIuyh3byQhcuCZeJb81hN3xAQ9x5Zlr4nrUgfTunBiNApu3mkDMcxRnJ1Q0uED_ZkonEdH1FOfv2BbYR1FtODRLF0u9S-ewZ1sfzjwdmu1VFheoYpPh22GZjSlFmxaMLNtH-IOnEL-ZzmOyQxFO1wSjXclTquS0IdfxcipylGw_9bdAEI1ihLbGSf28cTOHjoerCDqDtNZxfisW_rrelRVgdnoKIIvEcXT0dQ4hs390Lh8TCdrrtruZ1Nu3SdEUcsUiGc3xsf8P-Y3K68S86b5l5-sth9_6Yt6SwrlbyLa9uA",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJaTVhMTjNtOHl5Z0p5UnZHQTlQaHBlT0pWMFg2dHhfMlZDZndFd1dBVjRnIn0.eyJqdGkiOiJhNGJhZTQ2ZC01OWY5LTQwZTctOWM5Yi05N2Y0MjVlZDJjYTMiLCJleHAiOjE1MzMxMDYyNTAsIm5iZiI6MCwiaWF0IjoxNTMzMTA0NDUwLCJpc3MiOiJodHRwczovL3NlY3VyZS1zc28tYXBwbGUuMTI3LjAuMC4xLm5pcC5pby9hdXRoL3JlYWxtcy9jb29sc3RvcmUiLCJhdWQiOiJjdXJsIiwic3ViIjoiNmY2MzBmMTMtNTczNy00NmNiLWI5MjUtYmNkNmE0MzMwODNjIiwidHlwIjoiUmVmcmVzaCIsImF6cCI6ImN1cmwiLCJhdXRoX3RpbWUiOjAsInNlc3Npb25fc3RhdGUiOiI5YjA5YWYyNy1lODFmLTRkOTEtOGNkMS04OWYwY2M3YTBiYzEiLCJyZWFsbV9hY2Nlc3MiOnsicm9sZXMiOlsidW1hX2F1dGhvcml6YXRpb24iLCJjb29sc3RvcmUiXX0sInJlc291cmNlX2FjY2VzcyI6eyJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19fQ.NpWf_xmJjhRUbl8nt43lXzHHn0Z5g_LOHmQPaBSsoRdOvLHggm_DrPyccmosDc1rezILiFvFtYNcv6056HE1Y2stSzzsLj5frh--GZBw1ZiM5dwCwrr4Lf_8rIu9SIwGjl2ADdNETcr0JOGvqxwwIq5ihjeVsU0fV1VNHYPWbiQegEun-g8M3Li0f1movDmPF7pJUi_LyVv1-WObzVbdbs7W6Zi_NbRJkQ_--DAQMw7nsZXNefF1Jn50Wop79kHYwHqtMjFZi5-LU13fW2fS5tCTIbcmpKdUz3DxHmlovouEWP0ofqT_Fl55U7g3z_GVAXyAHTphHNOO7UPv0Scu8w",
  "token_type": "bearer",
  "not-before-policy": 0,
  "session_state": "9b09af27-e81f-4d91-8cd1-89f0cc7a0bc1"
}
----
* The Red Hat SSO server response contains a set of two tokens--an access token and a refresh token.
. Extract the access token in an environment variable:
+
[source,text]
----
export TKN=$(curl -X POST "$RHSSO_URL/auth/realms/coolstore/protocol/openid-connect/token"  \
           -H "Content-Type: application/x-www-form-urlencoded"  \
           -d "username=user1"  \
           -d "password=user"  \
           -d "grant_type=password" \
           -d "client_id=curl" \
           --insecure | jq '.access_token')
----

== Secure Catalog Service WildFly Swarm Application

WildFly Swarm comes with a Red Hat SSO/Keycloak fraction that enables the application for SSO using token-based authentication by integrating the Keycloak adapter for WildFly into the Swarm application.

=== In RHSSO create infra for Test Case
.  Create a realm `coolstore-test` in rhsso server.
*  Mousehover the top left corner drop down menu that is titled with `Coolstore`. The last entry of this drop down menu is always `Add Realm`. Click this to add a realm
. Follow the instruction <<Deploy Red Hat SSO on OpenShift>> to create role `coolstore-test`



=== Configure Application to Use Keycloak

There are essentially two ways to configure secure endpoints--through a `web.xml` descriptor or by configuring the secure endpoints in the Swarm configuration file. In this section, you configure the secure endpoints using the second method and then produce a Keycloak configuration file.

. In the POM file of the catalog service project, add the `org.wildfly.swarm:keycloak` dependency.

. In the POM file of the project, add the following line to the `<build>` section:
+
[source,xml]
----
<finalName>${project.artifactId}</finalName>
----

. In the `project-local.yml` configuration file, add the following contents under the `swarm` tag:
+
[source,yaml]
----
  deployment:
    catalog-service.war:
      web:
        login-config:
          auth-method: KEYCLOAK
        security-constraints:
          - url-pattern: /catalog/*
            methods: [GET]
            roles: [coolstore-test]
----
* This marks the `GET /catalog/*` URL pattern as a secured resource requiring the `coolstore` role.

* Also note that you use `KEYCLOAK` as the login configuration method, which delegates the security handling to the Keycloak adapter that itself is installed by the Keycloak fraction.

. In the `src/test/resources` folder of the project, create a file called `keycloak.json`.
* Keycloak requires a configuration file called `keycloak.json` on the classpath. When deployed on OpenShift, you provide this configuration file with a ConfigMap. For testing, however, you can add this file to the test resources.

. Paste the following contents into the file:
+
[source,json]
----
{
  "realm": "coolstore-test",
  "bearer-only": true,
  "auth-server-url": "https://rhsso:8443/auth",
  "realm-public-key": "",
  "resource": "coolstore-test"
}
----
* `realm` is the name of the realm.
* `resource` is the client ID of the application. Each application has a client ID that is used to identify the application.
* `bearer-only` verifies only bearer tokens if enabled and and does not attempt to authenticate users.
* `auth-server-url` is the base URL of the Keycloak server. This must match the issuer field in the token.
* `realm-public-key` is the realm public key, which is used to verify the signature of the token. It is not to be used in a production setting. If not set, the Keycloak adapter downloads the public key from the Red Hat SSO server.
. In the `RestApiTest` test class, add `keycloak.json` to the web archive in the `createDeployment` method, making sure that the web archive is called `catalog-service.war`.
* Expect the method to look like this:
+
[source,java]
----
    @Deployment
    public static Archive<?> createDeployment() {
    MavenResolvedArtifact[] artifacts = Maven.resolver().loadPomFromFile("pom.xml")
             .importDependencies(ScopeType.TEST).resolve()
             .withoutTransitivity().asResolvedArtifact();
     Optional<MavenResolvedArtifact> dep = Arrays.stream(artifacts)
             .filter(a -> a.getCoordinate().getArtifactId().equals("bcprov-jdk15on")).findFirst();

     WebArchive archive =  ShrinkWrap.create(WebArchive.class, "catalog-service.war")
             .addPackages(true,CatalogResource.class.getPackage())
     .addPackage(CatalogService.class.getPackage())
     .addPackage(Product.class.getPackage())
             .addAsResource("project-local.yml", "project-local.yml")
             .addAsResource("META-INF/test-persistence.xml",  "META-INF/persistence.xml")
             .addAsResource("META-INF/test-load.sql",  "META-INF/test-load.sql")
             .addAsWebInfResource("keycloak.json","keycloak.json");

     dep.ifPresent(d -> archive.addAsLibrary(d.asFile()));
     return archive;
    }
----

=== Generate Private and Public Keypair

In this section, you generate a private and public keypair using `openssl`.

. Open a terminal shell.

. Generate an RSA private and public keypair:
+
[source,text]
----
$ openssl genrsa -out keycloak.pem 2048
----
. Extract the public key:
+
[source,text]
----
$ openssl rsa -in keycloak.pem -outform PEM -pubout -out public.pem
----
. Extract the private key:
+
[source,text]
----
$ openssl rsa -in keycloak.pem -outform PEM -out private.pem
----
. Copy the `private.pem` file into the `src/test/resources` folder of the project.
. Open the `public.pem` file in a text editor, concatenate the public key string (the part between `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`), and paste the concatenated string in the `keycloak.json` file as the value for `realm-public-key`.

=== Run Test and Verify Token-Based Authentication

In this section, you run the `RestApiTest` to verify that token-based authentication works correctly. This initially fails and you fix the test by updating it to generate a valid access token and to pass this token in the requests to the REST endpoint in the tests. For this you can use the Keycloak core libraries.

. Execute the `RestApiTest` test class, using the Maven command line (`mvn clean test`) or in the IDE (*Run As -> JUnit test*).
* Because the REST request in the test does not have an `Authorization` header with a valid access token, expect the `testGetProduct` test method to fail with a 401 HTTP status code.
* Because the health endpoint is an unprotected resource, the `testHealthCheck` test method passes.
. In the project's POM file, add the `org.bouncycastle:bcprov-jdk15on:1.52:1.56.0.redhat-2` dependency with scope `test`.
* BouncyCastle is a set of open source libraries for Java cryptography. Keycloak uses this library for generating keys and signing tokens.
. In the `RestApiTest` class, add a `readPrivateKey` method to read out the `private.pem` private key and return a `java.security.PrivateKey` instance:
+
[source,java]
----
    private PrivateKey readPrivateKey() throws Exception {
        Security.addProvider(new BouncyCastleProvider());
        KeyFactory factory = KeyFactory.getInstance("RSA", "BC");
        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("private.pem");
        PemReader privateKeyReader = new PemReader(new InputStreamReader(is));
        try {
            PemObject privObject = privateKeyReader.readPemObject();
            PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(privObject.getContent());
            PrivateKey privateKey = factory.generatePrivate(privKeySpec);
            return privateKey;
        } finally {
            privateKeyReader.close();
        }
    }
----
. In the `RestApiTest` class, add a `createAccessToken` method to create a `org.keycloak.representations.AccessToken` access token and sign it with the private key:
+
[source,java]
----
    private String createAccessToken(String role, int issuedAt) throws Exception {
        AccessToken token = new AccessToken();
        token.type(TokenUtil.TOKEN_TYPE_BEARER);
        token.subject("testuser");
        token.issuedAt(issuedAt);
        token.issuer("https://rhsso:8443/auth/realms/coolstore-test");
        token.expiration(issuedAt + 300);
        token.setAllowedOrigins(new HashSet<>());

        AccessToken.Access access = new AccessToken.Access();
        token.setRealmAccess(access);
        access.addRole(role);

        Algorithm jwsAlgorithm = Algorithm.RS256;
        PrivateKey privateKey = readPrivateKey();
        String encodedToken = new JWSBuilder().type("JWT").jsonContent(token).sign(jwsAlgorithm, privateKey);
        return encodedToken;
    }
----
* Note that the issuer is set to the realm URL. The name of the realm -- `coolstore-test` -- corresponds to the realm name in `keycloak.json`. If they do not match, the token verification fails.
. In the `RestApiTest` class, add methods to generate valid and invalid (expired) tokens:
+
[source,java]
----
    private String getValidAccessToken(String role) throws Exception {
        return createAccessToken(role, (int) (System.currentTimeMillis() / 1000));
    }

    private String getExpiredAccessToken(String role) throws Exception {
        return createAccessToken(role, (int) ((System.currentTimeMillis() / 1000)-600));
    }
----
. In the `testGetProduct` method, add an `Authorization` header to the REST requests in the test by replacing this snippet:
+
[source,java]
----
Response response = target.request(MediaType.APPLICATION_JSON).get();
----
+
with this:
+
[source,java]
----
Response response = target.request(MediaType.APPLICATION_JSON)
    .header("Authorization", "Bearer " + getValidAccessToken("coolstore")).get();
----
* To add a header to the request, you must call the `header()` method on the `ResponseBuilder`.
* In the test, you are using a JAX-RS client to call the REST endpoint.
. Run the tests in the `RestApiTest` test class again.
* This time expect the tests to pass.
. Optionally, create additional test methods that call the endpoints with an expired token or a token that has the wrong role.
* Expect these tests to return a 401 HTTP status code (indicating an expired token) or 403 (indicating the wrong role in the token).

== Deploy and Test Secured WildFly Swarm Application

You deployed the catalog service on OpenShift in previous labs. In this section, you deploy and test the secured version of the catalog service.

=== Deploy Postgresql
. Create a new openshift project
+
[source,sh]
----
$ export SECURE_CATALOG_PRJ=<OpenShift secured catalog service project name>
$ oc new-project $SECURE_CATALOG_PRJ
----
. Deploy PostgreSQL using the `postgresql` image from the OpenShift namespace:
+
[source,sh]
----
oc new-app postgresql-persistent -e POSTGRESQL_USER=jboss -e POSTGRESQL_PASSWORD=jboss -e POSTGRESQL_DATABASE=catalogdb  -pDATABASE_SERVICE_NAME=catalog-postgresql
----


=== Configure Application to Use Keycloak

. Add the secure endpoint configuration to the `catalog-service` ConfigMap in the OpenShift catalog service project.
. In the `etc` folder of the project, create a file called `keycloak.json` with the following contents:
+
[source,json]
----
{
  "realm": "coolstore",
  "bearer-only": true,
  "auth-server-url": "",
  "ssl-required": "external",
  "realm-public-key": "",
  "resource": "coolstore"
}
----
. Set the value of `auth-server-url` to the HTTPS URL of the Red Hat SSO server suffixed with `/auth`.
. Paste the Red Hat SSO Coolstore realm public key as the value for `rhsso-public-key`.
* You can find this value by examining the `keycloak.json` file from the catalog service.

=== Mount ConfigMap

In this section, you create a ConfigMap from the `keycloak.json` file. You then mount it as a volume and point WildFly Swarm to the mounted `keycloak.json`.

. Create a ConfigMap called `catalog-service-rhsso` in the catalog service project on OpenShift from the `keycloak.json` file:
+
[source,text]
----
$ oc create configmap catalog-service-rhsso --from-file=etc/keycloak.json -n $SECURE_CATALOG_PRJ
----
. Review the `keycloak` deployment properties in `etc/project-defaults.yml`
. Also create the configmap `app-config` from `project-defaults.yml` to define the deployment properties related to database and keycloak.
+
----
$  oc create configmap app-config --from-file=etc/project-defaults.yml -n $SECURE_CATALOG_PRJ
----
. Review the `src/main/fabric8/deployment.yml` file, to check the env variable `JAVA_OPTIONS`, `volumes` and `volumeMounts` section. The `deployment.yml` will appear as:
+
[source,yaml]
----
spec:
  template:
    spec:
      containers:
        - readinessProbe:
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            failureThreshold: 3
            initialDelaySeconds: 20
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            failureThreshold: 2
            initialDelaySeconds: 60
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            limits:
              cpu: 1
              memory: 1Gi
            requests:
              cpu: 100m
              memory: 500Mi
          volumeMounts:
            - name: config
              mountPath: /app/config
            - name: rhsso-config
              mountPath: /app/rhsso-config
          env:
            - name: JAVA_OPTIONS
              value: "-Dswarm.project.stage.file=file:///app/config/project-defaults.yml -Dswarm.keycloak.json.path=/app/rhsso-config/keycloak.json"
            - name: GC_MAX_METASPACE_SIZE
              value: '200'
      volumes:
        - configMap:
            name: app-config
          name: config
        - configMap:
            name: catalog-service-rhsso
          name: rhsso-config
----

=== Deploy and Test Secured Catalog Service

. Deploy the catalog service with the Fabric8 Maven plug-in:
+
[source,text]
----
$ mvn clean fabric8:deploy -Popenshift -DskipTests=true -Dfabric8.namespace=$SECURE_CATALOG_PRJ
----

. Once the pod is up running,Test the catalog service without an authentication token:
+
[source,text]
----
$ export CATALOG_URL=http://$(oc get route catalog-service -n $SECURE_CATALOG_PRJ -o template --template='{{.spec.host}}')
$ curl -X GET "$CATALOG_URL/catalog/products"
----
* Expect to receive `Unauthorized` in the response:
+
.Sample Output
[source,xml]
----
<html><head><title>Error</title></head><body>Unauthorized</body></html>
----
. Obtain a token from the Red Hat SSO server as explained in the paragraph on installing the Red Hat SSO server.
. Test the catalog service with a valid authentication token:
+
[source,text]
----
$ curl -X GET -H "Authorization: Bearer $TKN" "$CATALOG_URL/catalog/products"
----
* Expect to receive the correct catalog data in the response:
+
.Sample Output
[source,json]
----
[
  {
    "itemId": "329299",
    "name": "Redhat",
    "description": "Red Fedora Official Red Hat Fedora",
    "price": 34.99
  },
  {
    "itemId": "329199",
    "name": "catalog",
    "description": "Forge Laptop Sticker JBoss Community Forge Project Sticker",
    "price": 8.5
  },
  {
    "itemId": "165613",
    "name": "catalog",
    "description": "Solid Performance Polo Moir.",
    "price": 17.8
  },
  {
    "itemId": "444456",
    "name": "catalog",
    "description": "Red Fedora Official Red Hat Fedora",
    "price": 34.99
  },
  {
    "itemId": "444435",
    "name": "catalog",
    "description": "Tokyo Official Red Hat Fedora",
    "price": 34.99
  },
  {
    "itemId": "444436",
    "name": "catalog",
    "description": "India Official Red Hat Fedora",
    "price": 34.99
  }
]
----

== Secure Spring Boot Cart Service
Red Hat SSO comes with an adapter for Spring applications and provides a starter for Spring Boot. This starter also includes the Keycloak Spring Security adapter to integrate Keycloak with Spring Security. Spring Security brings security to Spring applications by leveraging the Spring programming model.

=== Configure Application to Use Keycloak

. In the POM file of the cart service project, add the `org.keycloak:keycloak-spring-boot-starter:3.1.0.Final` dependency.
* This artifact is a community version, as the Keycloak Spring Boot starter with Spring Security integration was added only recently and is not part of the current Red Hat SSO product. It is backward-compatible with the current version of the Red Hat SSO server.
. In the POM file of the cart service project, add the `org.springframework.boot:spring-boot-starter-security` dependency.

. For testing purposes, add the following properties to `application-test.properties` in the `src/test/resources` folder of the project:
+
[source,text]
----
keycloak.auth-server-url=https://rhsso:8443/auth
keycloak.realm=coolstore-test
keycloak.bearer-only=true
keycloak.realmKey=
keycloak.resource=coolstore-test
----
* When using the Keycloak Spring adapter, the Keycloak configuration parameters can be added to the application configuration files, prefixed with `keycloak`. When deploying to OpenShift, you supply the configuration data in a ConfigMap.
* Refer to the previous section for the meaning of these configuration parameters.
. Copy the public key from `keycloak.json` in the catalog service project and paste it as the value of `keycloak.realmKey` in `application-test.properties`.
* You reuse the private and public keys generated for the catalog service tests.
. Copy the `private.pem` private key from the `src/test/resources` folder of the catalog service project to the `src/test/resources` folder.

=== Update Cart Service Implementation for Keycloak

To integrate with Spring Security, a configuration class extending `org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter` is required. Keycloak provides a subclass of `WebSecurityConfigurerAdapter` that you can override to use Keycloak as the Spring Security authentication and authorization handler.

. In the `com.redhat.coolstore.cart` package, create a `CartServiceSecurityConfig` class that extends `KeycloakWebSecurityConfigurerAdapter` and annotate the class as follows:
+
[source,java]
----
@EnableWebSecurity
@Configuration
@ComponentScan(basePackageClasses = KeycloakSecurityComponents.class)
public class CartServiceSecurityConfig extends KeycloakWebSecurityConfigurerAdapter {

}
----
. Add a method to enable support for Keycloak configuration with Spring Boot properties files:
+
[source,java]
----
    @Bean
    public KeycloakConfigResolver KeycloakConfigResolver() {
        return new KeycloakSpringBootConfigResolver();
    }
----
. Add a method to configure Spring Security with a role mapper implementation that does not require the `ROLE_` prefix:
+
[source,java]
----
    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        KeycloakAuthenticationProvider keycloakAuthenticationProvider = keycloakAuthenticationProvider();
        keycloakAuthenticationProvider.setGrantedAuthoritiesMapper(new SimpleAuthorityMapper());
        auth.authenticationProvider(keycloakAuthenticationProvider);
    }
----
* By default in Spring Security, roles are prefixed with `ROLE_`. Rather than enforce this convention in the Red Hat SSO server--which would force all other application in the same realm to follow the convention--you configure Spring Security with a role mapper implementation that does not require the prefix.
. Add the required `sessionAuthenticationStrategy` method to the class:
+
[source,java]
----
    @Override
    protected SessionAuthenticationStrategy sessionAuthenticationStrategy() {
        return new NullAuthenticatedSessionStrategy();
    }
----
* `KeycloakWebSecurityConfigurerAdapter` subclasses must implement the `sessionAuthenticationStrategy()` method to set how the HTTP session is to be handled when authentication occurs. The cart service is a stateless application that does not use HTTP sessions, so you can use the `NullAuthenticatedSessionStrategy`.
. Add two methods to the class to create required `FilterRegistrationBean` beans:
+
[source,java]
----
    @Bean
    public FilterRegistrationBean keycloakAuthenticationProcessingFilterRegistrationBean(KeycloakAuthenticationProcessingFilter filter) {
        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);
        registrationBean.setEnabled(false);
        return registrationBean;
    }

    @Bean
    public FilterRegistrationBean keycloakPreAuthActionsFilterRegistrationBean(KeycloakPreAuthActionsFilter filter) {
        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);
        registrationBean.setEnabled(false);
        return registrationBean;
    }
----
* Spring Boot attempts to eagerly register filter beans with the web application context. So when running the Keycloak Spring Security adapter in a Spring Boot environment, it is necessary to add two `FilterRegistrationBean` beans to your security configuration to prevent the Keycloak filters from being registered twice.
. Override the `configure` method to define which endpoints to secure by adding the following method to the class:
+
[source,java]
----
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http);
        http.csrf().disable()
            .authorizeRequests().antMatchers("/cart/**").hasRole("coolstore")
            .anyRequest().permitAll();
    }
----
* This configuration secures the endpoint with the `/cart/**` URL pattern, while keeping all of the other endpoints--specifically in this lab, the health check endpoints--unsecured.
* The cart endpoints require the `coolstore` role.
* CSRF (Cross-Site Request Forgery) is enabled by default when using Spring Security `WebSecurityConfigurerAdapter`. It must be disabled for bearer token authentication to work.

=== Run and Fix Tests

In this section, you first run the existing tests, which fail because you do not pass a bearer token in the REST requests. Then you fix the tests and verify that token-based authentication works correctly. You update the tests to generate a valid access token and to pass this token in the requests to the REST endpoint. You can reuse the code you introduced in the tests for the cart service.

. Run the tests in the `com.redhat.coolstore.cart.rest` package.
* Expect the tests in the `CartEndpointTest` class to fail with a 401 HTTP status code, while the tests in the `HealthCheckEndpointTests` pass. The `CartEndpointTest` test fails because the `CartEndpoint` URL is secured and the test does not pass a bearer token with the REST requests.
. Copy the `createAccessToken`, `readPrivateKey`, `getValidAccessToken`, and `getExpiredAccessToken` methods from the `RestApiRest` class in the cart service project,  and paste them in the `CartEndpointTest` class.
. Update the `retrieveCartById` method of the `CartEndpointTest` class to add an `Authorization` header with a token when invoking the REST requests to the secured endpoints using the `auth` and `oauth2` directives of RestAssured:
+
[source,java]
----
    @Test
    public void retrieveCartById() throws Exception {
        RestAssured.given()
            .auth().oauth2(getValidAccessToken("coolstore"))
            .get("/{cartId}", "123456")
            .then()
            .assertThat()
            .statusCode(200)
            .contentType(ContentType.JSON)
            .body("id", equalTo("123456"));
    }
----
. Run the tests again.
* Expect the `retrieveCartById` test to pass now. All of the other test methods for the cart service endpoints still fail.
. Fix the other tests.
. Optionally, create some additional test methods that call the cart service endpoints with an expired token or a token that has the wrong role.
* Expect these tests to return a 401 HTTP status code (indicating an expired token) or 403 (indicating the wrong role in the token).

=== Update Cart Service to Use Access Token

The cart service calls the catalog service to obtain product data. Now that the catalog service is secured with Red Hat SSO and requires an access token, the cart service must pass the access token whenever it calls the catalog service. The Keycloak Spring Security adapter has a `KeycloakRestTemplate` class that extends the Spring `RestTemplate` and handles this transparently.

After successful token verification, Spring Security keeps the authentication information, including the access token in the `SecurityContextHolder` context as a thread-local variable. The `KeycloakRestTemplate` implementation extracts the access token from the security context and adds it to an `Authorization` header on the outgoing REST call.

. In the `CatalogServiceImpl` class in the `com.redhat.coolstore.cart service` package, inject a `KeycloakClientRequestFactory` bean:
+
[source,java]
----
    @Autowired
    private KeycloakClientRequestFactory keycloakClientRequestFactory;
----
. In the `getProduct` method, replace the `RestTemplate` instance with `KeyCloakRestTemplate`:
+
[source,java]
----
RestTemplate restTemplate = new KeycloakRestTemplate(clientRequestFactory);
----
. In the `CatalogServiceImplTest` test methods, inject the `KeycloakClientRequestFactory` with `ReflectionTestUtils`:
+
[source,java]
----
CatalogServiceImpl catalogService = new CatalogServiceImpl();
ReflectionTestUtils.setField(catalogService, "catalogServiceUrl", "http://localhost:" + wireMockRule.port(), null);
ReflectionTestUtils.setField(catalogService, null, new KeycloakClientRequestFactory(), KeycloakClientRequestFactory.class);
----

=== Run Catalog Service Tests

In this section, you run the `CatalogServiceImplTest` tests, which all initially fail. To fix this, you set a Keycloak principal containing an access token on the Spring Security context.

. Run the `CatalogServiceImplTest` tests.
* Note that all of the tests fail with a `java.lang.IllegalStateException: Cannot set authorization header because there is no authenticated principal`.
. Add the following code to the `CatalogServiceImpTest`:
+
[source,java]
----
    private String bearerTokenString;

    @Before
    public void before() {
        bearerTokenString = UUID.randomUUID().toString();
        KeycloakAuthenticationToken keycloakAuthenticationToken = Mockito.mock(KeycloakAuthenticationToken.class);
        OidcKeycloakAccount account = Mockito.mock(OidcKeycloakAccount.class);
        KeycloakSecurityContext keycloakSecurityContext = Mockito.mock(KeycloakSecurityContext.class);
        SecurityContextHolder.getContext().setAuthentication(keycloakAuthenticationToken);
        when(keycloakAuthenticationToken.getAccount()).thenReturn(account);
        when(account.getKeycloakSecurityContext()).thenReturn(keycloakSecurityContext);
        when(keycloakSecurityContext.getTokenString()).thenReturn(bearerTokenString);
    }
----
. Run the tests again.
* Expect the tests to pass.
. Add the expected authorization header to the WireMock stub to verify that the access token is being passed to the mocked catalog service:
+
[source,java]
----
WireMock.stubFor(
    WireMock.get(WireMock.urlEqualTo("/product/111111"))
    .withHeader("Authorization", WireMock.equalTo("Bearer " + bearerTokenString))
    .willReturn(aResponse()
        .withStatus(200)
        .withHeader("Content-type", "application/json")
        .withBody(IOUtils.toString(is, Charset.defaultCharset()))));
----
* The WireMock stub is matched only if the `Authorization` header with the expected value is present on the REST request.
. Run the tests again.
* Expect the tests to pass.

== Deploy and Test Secured Cart Service Spring Boot Application

You deployed the cart and catalog services on OpenShift in previous labs. In this section, you deploy and test the secured version of the cart service. Before you can deploy the secured cart service to OpenShift, you must add the Red Hat SSO configuration to the application configuration properties in the ConfigMap.

=== Add Red Hat SSO Properties to ConfigMap

In this section, you add the Red Hat SSO configuration properties to the ConfigMap. You have two options--you can use the command line and `vi` or the OpenShift web console.

==== Option 1: Add Red Hat SSO Properties to ConfigMap with CLI

In this section, you add the Red Hat SSO configuration properties to the ConfigMap using the command line. If you are not comfortable with the command line and `vi`, use the instructions in the next section that use the OpenShift web console.

. Open a terminal shell and export the name of the cart service OpenShift project as a environment variable:
+
[source,text]
----
$ export CART_PRJ=<OpenShift cart service project name>
----
. Open the `cart-service` ConfigMap for editing:
+
[source,text]
----
$ oc edit configmap cart-service -n $CART_PRJ
----
* The ConfigMap opens in `vi`.

. Under the existing properties, add the following entries:
+
[source,yaml]
----
keycloak.realm: 'coolstore'
keycloak.bearer-only: 'true'
keycloak.resource: 'coolstore'
keycloak.auth-server-url: ''
keycloak.realmKey: ''
----
* Remember that indentation is important.
. Between the single quotes, enter the HTTPS URL of the Red Hat SSO server suffixed with `/auth` as the value for `keycloak.auth-server-url`.
. Between the single quotes, paste the Red Hat SSO Coolstore realm public key as the value for `keycloak.realmKey`.
* Expect the ConfigMap to look like this, but the value of your URL and the public key to be different from the example:
+
[source,yaml]
----
# Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: v1
data:
  catalog.service.url: http://catalog-service.coolstore-catalog.svc:8080
  keycloak.realm: 'coolstore'
  keycloak.bearer-only: 'true'
  keycloak.resource: 'coolstore'
  keycloak.auth-server-url: 'https://secure-sso-infra.apps.ocp.local.cluster/auth'
  keycloak.realmKey: 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnPmRZFx7I2hYBdcEDZtiCqpqVK+6NhRICaL7ZxvI4YthGji7oodUuPC+z9ioQ67DT47josx2m8pD+fPGnSwU8Ogcdx/7U7msI6rQi7Lwuj/ITPwKqxqElcAWdK37L3wr7bTscV8/5q7uhtQPY1t6/0Uu0xMZG8f1Loup3i0tnD8j2u930pPnLdwaWbeFEt613dMzTYDZB2gAQEKwz6v4TC8Wn3InlkIm3Q6cAE1D3xAwCRwzLUYEENEQ59Bwt9HKhaERJuIZahJmpG2Y7C1IlHuCO5z4WduXYDUa9tUSNOXZ3g02eyVZ/8IuAjr2weFCHWcPrTsJq671hrxmId9kawIDAQAB'
kind: ConfigMap
metadata:
  creationTimestamp: 2017-08-14T20:08:42Z
  name: cart-service
  namespace: coolstore-cart
  resourceVersion: "14067"
  selfLink: /api/v1/namespaces/coolstore-cart/configmaps/cart-service
  uid: 5e7c459e-812c-11e7-9e8a-507b9d27afbf
----
. Save the ConfigMap.

==== Option 2: Add Red Hat SSO Properties to ConfigMap with OpenShift Web Console

In this section, you edit the ConfigMap in the OpenShift web console.

. Navigate to the OpenShift Console and open the cart service project.
. In the menu on the right, select *Resources* and *Config Maps*.
. Open the `cart-service` ConfigMap.
. Click *Actions* and select *Edit YAML*.
. Under the existing properties, paste the following contents, remembering to preserve the identation:
+
[source,yaml]
----
keycloak.realm: 'coolstore'
keycloak.bearer-only: 'true'
keycloak.resource: 'coolstore'
keycloak.auth-server-url: ''
keycloak.realmKey: ''
----
. Add the HTTPS URL of the Red Hat SSO server suffixed with `/auth` as the value for `keycloak.auth-server-url` and surround it with single quotes.

. Paste the Red Hat SSO Coolstore realm public key as the value for `keycloak.realmKey` and surround it with single quotes:
+
image::images/ocp-configmap-cart.png[]
. Click *Save*.

=== Deploy and Test

. Deploy the cart service to OpenShift with the Fabric8 Maven plug-in:
+
[source,text]
----
$ export CART_PRJ=<OpenShift cart service project name>
$ mvn clean fabric8:deploy -Popenshift -DskipTests=true -Dfabric8.namespace=$CART_PRJ
----
. Test the cart service without an authentication token:
+
[source,text]
----
$ export CART_URL=http://$(oc get route cart-service -n $CART_PRJ -o template --template='{{.spec.host}}')
$ curl -X GET "$CART_URL/cart/mycart"
----
* Expect to receive `Unauthorized` in the response:
+
.Sample Output
[source,html]
----
<!DOCTYPE html><html><head><title>Apache Tomcat/8.5.5 - Error report</title><style type="text/css">H1 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:22px;} H2 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:16px;} H3 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:14px;} BODY {font-family:Tahoma,Arial,sans-serif;color:black;background-color:white;} B {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;} P {font-family:Tahoma,Arial,sans-serif;background:white;color:black;font-size:12px;}A {color : black;}A.name {color : black;}.line {height: 1px; background-color: #525D76; border: none;}</style> </head><body><h1>HTTP Status 401 - Unauthorized</h1><div class="line"></div><p><b>type</b> Status report</p><p><b>message</b> <u>Unauthorized</u></p><p><b>description</b> <u>This request requires HTTP authentication.</u></p><hr class="line"><h3>Apache Tomcat/8.5.5</h3></body></html>
----
. Obtain a token from the Red Hat SSO server as explained in the paragraph on installing the Red Hat SSO server.
. Test the cart service with a valid authentication token:
+
[source,text]
----
$ curl -X GET -H "Authorization: Bearer $TKN" "$CART_URL/cart/mycart"
----
* Look for the expected data in the response:
+
[source,json]
----
{
  "id": "mycart",
  "cartItemTotal": 0,
  "shippingTotal": 0,
  "cartTotal": 0,
  "shoppingCartItemList": []
}
----
. Verify that the access token is passed successfully to the catalog service:
+
[source,text]
----
$ curl -X POST -H "Authorization: Bearer $TKN" "$CART_URL/cart/mycart/165614/2"
----
+
.Sample Output
[source,json]
----
{
  "id": "mycart",
  "cartItemTotal": 57.5,
  "shippingTotal": 6.99,
  "cartTotal": 64.49,
  "shoppingCartItemList": [
    {
      "price": 28.75,
      "quantity": 2,
      "product": {
        "itemId": "165614",
        "name": "Ogio Caliber Polo",
        "desc": "Moisture-wicking 100% polyester. Rib-knit collar and cuffs; Ogio jacquard tape inside neck; bar-tacked three-button placket with Ogio dyed-to-match buttons; side vents; tagless; Ogio badge on left sleeve. Import. Embroidery. Black.",
        "price": 28.75
      }
    }
  ]
}
----
. Check out the cart to further verify access to the secured service:
+
[source,text]
----
$ curl -X POST -H "Authorization: Bearer $TKN" "$CART_URL/cart/checkout/mycart"
----
+
.Sample Output
[source,json]
----
{
  "id": "mycart",
  "cartItemTotal": 0,
  "shippingTotal": 0,
  "cartTotal": 0,
  "shoppingCartItemList": []
}
----

Congratulations, you reached the end of the lab.
